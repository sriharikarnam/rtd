<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.9.1">
  <compounddef id="Synchonization" kind="page">
    <compoundname>Synchonization</compoundname>
    <detaileddescription>
<para><heading level="1">Host-synchronous behavior:</heading>
</para><para>The following commands are &quot;host-asynchronous&quot; - meaning they do not wait for any preceding commands to complete, and may return control to the host thread before the requested operation completes:</para><para><itemizedlist>
<listitem><para>Kernel launches (hipLaunchKernel() )</para></listitem><listitem><para>Asynchronous memory copies - any memory copy API which contains &quot;Async&quot;, such as <ref refid="group__Memory_1gad55fa9f5980b711bc93c52820149ba18" kindref="member">hipMemcpyAsync()</ref>)</para></listitem><listitem><para>Any memory set (for example, <ref refid="group__Memory_1gac7441e74affcce4b8b69dba996c5ebc4" kindref="member">hipMemset()</ref>);</para></listitem><listitem><para>TODO</para></listitem></itemizedlist>
</para><para>&quot;Host-synchronous&quot; commands have the following properties:<itemizedlist>
<listitem><para>wait for all previous commands to complete.</para></listitem><listitem><para>will not return control back to host until the command completes.</para></listitem></itemizedlist>
</para><para>The following commands are &quot;host-synchronous&quot;.</para><para><itemizedlist>
<listitem><para>hipMemcpy waits for preceding work in the same stream to complete.</para></listitem></itemizedlist>
</para><para><heading level="1">Stream synchronization</heading>
</para><para><heading level="3">Blocking</heading>
</para><para>The term &quot;blocking&quot; has two meanings in HIP.</para><para>The first refers to synchronization commands (ie hipStreamSynchronize, hipEventSynchronize) that cause the host CPU to wait for GPU activity to complete. These can either use an active where the host CPU spin-waits on the synchronization variable, or can use an interrupt-based scheme where the core is interrupted when the wait completes. The second technique is referred to as &quot;blocking&quot; (ie hipDeviceBlockingSync, hipEventBlockingSync) while the first is referred to as &quot;active&quot;. Active can be appropriate for short tasks where latency is critical, but comes at the expense of a CPU core dedicated to monitoring the event.</para><para><heading level="3">HIP_LAUNCH_BLOCKING (also can use CUDA_LAUNCH_BLOCKING)</heading>
</para><para><itemizedlist>
<listitem><para>The following commands become host-synchronous and will not return until the requested command has completed:<itemizedlist>
<listitem><para>Kernel launches (hipKernelLaunch).</para></listitem><listitem><para>Memory set commands (hipMemset, hipMemsetAsync).</para></listitem><listitem><para>Memory copy commands (hipMemcpy, hipMemsetAsync).</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para>Note CUDA_LAUNCH_BLOCKING does add any pre-serialization to the commands and does not affect the concurrent stream behavior. For example, even when CUDA_LAUNCH_BLOCKING is set, kernels or data copy commands launched to separate streams can execute concurrently. Use the NULL stream if additional stream synchronization is desired. </para>    </detaileddescription>
  </compounddef>
</doxygen>
